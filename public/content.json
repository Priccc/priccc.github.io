{"meta":{"title":"Priccc","subtitle":null,"description":null,"author":"张磊","url":"https://priccc.github.io"},"pages":[{"title":"","date":"2018-08-13T07:34:38.599Z","updated":"2018-08-13T07:34:38.599Z","comments":true,"path":"about/index.html","permalink":"https://priccc.github.io/about/index.html","excerpt":"","text":"张磊的个人博客 2018-08-13 优化"}],"posts":[{"title":"利用 canvas 实现字符流视频","slug":"string-video","date":"2018-08-13T16:00:00.000Z","updated":"2018-08-14T03:24:08.276Z","comments":true,"path":"2018/08/14/string-video/","link":"","permalink":"https://priccc.github.io/2018/08/14/string-video/","excerpt":"最近刷抖音越来越频繁，在里面页发现了不少技术相关的视频，今天这里说到的字符流视频就是其中之一 一开始我也是没有思路的，毕竟 canvas 基本没用过，只能在 百度、Google 上寻求答案… 实现思路 利用 input 获取到视频，并转成 HTMLVideDOM 将视频通过 drawImage() 画到 canvas 上，并通过 getImageData() 获取画布上的信息，计算灰度值，并替换成字符，越深替换的字符越密集 将替换好的字符视频画到画布上 更改视频的 currentTime 属性，通过 window.requestAnimationFrame() 重复 2、3 步 思路借鉴自 js视频转字符画 —— 写一个属于自己的字符转换器","text":"最近刷抖音越来越频繁，在里面页发现了不少技术相关的视频，今天这里说到的字符流视频就是其中之一 一开始我也是没有思路的，毕竟 canvas 基本没用过，只能在 百度、Google 上寻求答案… 实现思路 利用 input 获取到视频，并转成 HTMLVideDOM 将视频通过 drawImage() 画到 canvas 上，并通过 getImageData() 获取画布上的信息，计算灰度值，并替换成字符，越深替换的字符越密集 将替换好的字符视频画到画布上 更改视频的 currentTime 属性，通过 window.requestAnimationFrame() 重复 2、3 步 思路借鉴自 js视频转字符画 —— 写一个属于自己的字符转换器 页面初始化初始化页面大体布局，全局变量，CSS 样式看个人喜好 123456789101112131415161718192021...&lt;div id=&quot;container&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;input-file&quot; accept=&quot;.mp4&quot; /&gt; &lt;div id=&quot;video-box&quot;&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas-show&quot;&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; const inputFile = document.getElementById(&apos;input-file&apos;); // input const canvas = document.getElementById(&apos;canvas&apos;); // 画原始视频的 canvas const canvasShow = document.getElementById(&apos;canvas-show&apos;); // 画字符流视频的 canvas const ctx = canvas.getContext(&apos;2d&apos;); const ctxShow = canvasShow.getContext(&apos;2d&apos;); const size = &#123; w: 0, h: 0 &#125;; // 视频大小 let afid = null; // requestAnimationFrame 的 id let videoDom = document.createElement(&quot;VIDEO&quot;); ...&lt;/script&gt; 利用 input 获取到视频，并转成 HTMLVideDOM通过 input 的 change 事件，监听文件是否被上传了，并将上传的视频信息获取到，通过 URL.createObjectURL() 生成一个视频地址，并赋值给穿件好的 video 元素 await new Promise(res =&gt; videoDom.addEventListener(&#39;canplay&#39;, res)); 是为了等待视频被加载完成 最后规定一下视频的大小，开始执行动画操作 12345678910111213141516171819inputFile.addEventListener(&apos;change&apos;, async (&#123; target: &#123; files &#125; &#125;) =&gt; &#123; const file = files[0]; const url = URL.createObjectURL(file); videoDom.src = url; await new Promise(res =&gt; videoDom.addEventListener(&apos;canplay&apos;, res)); const &#123; videoHeight, videoWidth &#125; = videoDom; size.w = videoWidth * 0.5; size.h = videoHeight * 0.5; canvas.width = size.w; canvas.height = size.h; canvasShow.width = size.w; canvasShow.height = size.h; await playVideo();&#125;); 执行动画操作此部分是动画部分，主要是修改视频的当前时间，执行函数，并调用下次动画 12345678910111213141516171819202122232425const playVideo = async (&#123; currentTime = 0, curTime = Date.now(), prevTime = Date.now(), prevProgress,&#125; = &#123;&#125;) =&gt; &#123; videoDom.currentTime = currentTime; await new Promise(res =&gt; videoDom.addEventListener(&apos;canplay&apos;, res)); ctx.drawImage(videoDom, 0, 0, size.w, size.h); replaceImage(); let progress = Math.max(curTime - prevTime, 16) / 1000; const nextTime = currentTime + progress; if (nextTime &gt;= videoDom.duration) &#123; return clearVideo(); &#125; afid = window.requestAnimationFrame(() =&gt; playVideo(&#123; currentTime: nextTime, curTime: Date.now(), prevTime: curTime, prevProgress: progress, &#125;));&#125; 读取画布信息，并替换这是核心内容，大体思路是获取画布信息，然后计算灰度值，根据灰度值替换成相应的字符 但是如何计算灰度值呢 ？我也是百思不得其解啊，只能靠他人了，还别说，网上关于 canvas 计算灰度值的信息一大堆，公式为：gray color = 0.299 × red color + 0.578 × green color + 0.114 * blue color ，大体如下123456789for (let _h = 0; _h &lt; h; _h += 6) &#123; for (let _w= 0; _w&lt; w; _w += 6) &#123; const index = (_w + w * _h) * 4; const r = data[index + 0]; const g = data[index + 1]; const b = data[index + 2]; const gray = .299 * r + .587 * g + .114 * b; &#125;&#125; 然后再根据当前的灰度值替换成相应的字符 replaceText() 12345678910111213141516171819202122const replaceImage = () =&gt; &#123; const &#123; w, h &#125; = size; const &#123; data &#125; = ctx.getImageData(0, 0, w, h); ctxShow.clearRect(0, 0, w, h); for (let _h = 0; _h &lt; h; _h += 6) &#123; for (let _w= 0; _w&lt; w; _w += 6) &#123; const index = (_w + w * _h) * 4; const r = data[index + 0]; const g = data[index + 1]; const b = data[index + 2]; const gray = .299 * r + .587 * g + .114 * b; ctxShow.fillText(replaceText(gray), _w, _h + 8); &#125; &#125;&#125;const replaceText = (g) =&gt; &#123; const textList = [&apos;#&apos;, &apos;&amp;&apos;, &apos;@&apos;, &apos;%&apos;, &apos;$&apos;, &apos;w&apos;, &apos;*&apos;, &apos;+&apos;, &apos;o&apos;, &apos;?&apos;, &apos;!&apos;, &apos;;&apos;, &apos;^&apos;, &apos;,&apos;, &apos;.&apos;, &apos; &apos;]; const i = g % 16 === 0 ? parseInt(g / 16) - 1 : parseInt(g / 16); return textList[i];&#125; 效果图到现在为止，功能就已经实现了，小伙伴们可以去尝试一下效果吧…","categories":[{"name":"javascript","slug":"javascript","permalink":"https://priccc.github.io/categories/javascript/"}],"tags":[{"name":"抖音","slug":"抖音","permalink":"https://priccc.github.io/tags/抖音/"},{"name":"canvas","slug":"canvas","permalink":"https://priccc.github.io/tags/canvas/"},{"name":"javascript","slug":"javascript","permalink":"https://priccc.github.io/tags/javascript/"}]},{"title":"个人职业发展历程 TODOLIST","slug":"todo-list","date":"2018-08-12T16:00:00.000Z","updated":"2018-08-14T03:33:06.654Z","comments":true,"path":"2018/08/13/todo-list/","link":"","permalink":"https://priccc.github.io/2018/08/13/todo-list/","excerpt":"","text":"持续更新中… 个人静态博客 基础搭建已完成，待优化项： 添加评论功能 关于页面编写 持续优化… 利用 canvas 实现字符流视频☞ 个人照片视频库 （IOS APP）","categories":[{"name":"职业规划","slug":"职业规划","permalink":"https://priccc.github.io/categories/职业规划/"}],"tags":[]}]}